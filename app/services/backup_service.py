"""CSV backup service and daily scheduler."""

from __future__ import annotations

import asyncio
import csv
from dataclasses import dataclass
from datetime import date, datetime, timedelta
from pathlib import Path
from typing import Optional
from zoneinfo import ZoneInfo

import httpx
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker

from app.config import Settings
from app.security.telegram_auth import parse_allowed_ids
from app.services.entry_service import EntryService


@dataclass
class BackupResult:
    """Paths generated by backup export."""

    entries_csv: Path
    reports_csv: Path


class BackupService:
    """Generate and optionally send daily CSV backups."""

    def __init__(self, settings: Settings) -> None:
        self.settings = settings
        self.entry_service = EntryService()

    async def export_daily_csv(self, session: AsyncSession, target_date: date) -> BackupResult:
        """Export entries and report snapshot CSV for one day."""

        day_dir = Path(self.settings.backups_dir) / target_date.isoformat()
        day_dir.mkdir(parents=True, exist_ok=True)

        entries_path = day_dir / f"entries_{target_date.isoformat()}.csv"
        reports_path = day_dir / f"reports_{target_date.isoformat()}.csv"

        entries = await self.entry_service.entries_for_day(session, target_date)
        daily_profit = await self.entry_service.daily_profit_by_currency(session, target_date)
        balances = await self.entry_service.currency_balances(session)
        debts = await self.entry_service.client_debts(session)
        by_currency, uzs_total = await self.entry_service.cash_total(session)

        with entries_path.open("w", newline="", encoding="utf-8") as fp:
            writer = csv.writer(fp)
            writer.writerow(["id", "amount", "currency_code", "flow_direction", "client_name", "note", "created_at", "created_by_telegram_id"])
            for row in entries:
                writer.writerow(
                    [
                        row.id,
                        str(row.amount),
                        row.currency_code,
                        row.flow_direction,
                        row.client_name,
                        row.note or "",
                        row.created_at.isoformat() if row.created_at else "",
                        row.created_by_telegram_id,
                    ]
                )

        with reports_path.open("w", newline="", encoding="utf-8") as fp:
            writer = csv.writer(fp)
            writer.writerow(["section", "key", "value", "extra"])

            for currency, amount in sorted(daily_profit.items()):
                writer.writerow(["daily_profit", currency, str(amount), ""])

            for currency, amount in sorted(balances.items()):
                writer.writerow(["currency_balance", currency, str(amount), ""])

            for client_name, currency, debt in debts:
                writer.writerow(["client_debt", client_name, str(debt), currency])

            for currency, amount in sorted(by_currency.items()):
                writer.writerow(["cash_total", currency, str(amount), ""])
            writer.writerow(["cash_total", "UZS_TOTAL", str(uzs_total), ""])

        return BackupResult(entries_csv=entries_path, reports_csv=reports_path)

    async def send_backup_to_telegram(self, result: BackupResult) -> None:
        """Send generated CSV files to first allowed Telegram admin ID."""

        allowed = sorted(parse_allowed_ids(self.settings.allowed_telegram_ids))
        if not allowed:
            return
        if not self.settings.telegram_bot_token:
            return

        admin_id = allowed[0]
        bot_api = f"https://api.telegram.org/bot{self.settings.telegram_bot_token}/sendDocument"

        async with httpx.AsyncClient(timeout=45) as client:
            for path in [result.entries_csv, result.reports_csv]:
                with path.open("rb") as fp:
                    files = {"document": (path.name, fp, "text/csv")}
                    data = {"chat_id": str(admin_id), "caption": f"Daily backup: {path.name}"}
                    response = await client.post(bot_api, data=data, files=files)
                    response.raise_for_status()


class BackupScheduler:
    """Background daily backup scheduler."""

    def __init__(self, session_factory: async_sessionmaker[AsyncSession], settings: Settings) -> None:
        self._session_factory = session_factory
        self._settings = settings
        self._service = BackupService(settings)
        self._task: Optional[asyncio.Task] = None

    def start(self) -> None:
        """Start scheduler task if not running."""

        if self._task is None or self._task.done():
            self._task = asyncio.create_task(self._run_loop(), name="daily-backup-scheduler")

    async def stop(self) -> None:
        """Stop scheduler task."""

        if self._task is None:
            return
        self._task.cancel()
        try:
            await self._task
        except asyncio.CancelledError:
            pass

    async def run_once(self, target_date: date) -> BackupResult:
        """Run one backup cycle manually."""

        async with self._session_factory() as session:
            result = await self._service.export_daily_csv(session, target_date)
        await self._service.send_backup_to_telegram(result)
        return result

    async def _run_loop(self) -> None:
        """Sleep until configured time and execute daily backup forever."""

        tz = ZoneInfo(self._settings.timezone)
        while True:
            now = datetime.now(tz)
            run_at = now.replace(
                hour=self._settings.backup_hour,
                minute=self._settings.backup_minute,
                second=0,
                microsecond=0,
            )
            if run_at <= now:
                run_at = run_at + timedelta(days=1)

            sleep_for = max((run_at - now).total_seconds(), 1)
            await asyncio.sleep(sleep_for)

            try:
                await self.run_once(datetime.now(tz).date())
            except Exception as exc:  # noqa: BLE001
                print(f"Backup scheduler error: {exc}")
